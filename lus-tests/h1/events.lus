global print, require, assert, type, table, setmetatable, getmetatable, collectgarbage, math, error, rawget, rawset, rawequal, rawlen, pairs, tostring, next, _G, io, debug, string

local framework = require("lus-tests.framework")
local debug = require'debug'
local tests = framework.new("events")

tests:it("metatable basics", function()
    local t = {}
    assert(getmetatable(t) == nil)
    local t1 = {}
    setmetatable(t, t1)
    assert(getmetatable(t) == t1)
    assert(setmetatable(t, nil) == t)
    assert(getmetatable(t) == nil)
end)

tests:it("protected metatable", function()
    local a = {name = "NAME"}
    setmetatable(a, {__metatable = "xuxu", __tostring = function(x) return x.name end})
    assert(getmetatable(a) == "xuxu")
    assert(tostring(a) == "NAME")
    -- cannot change protected metatable
    assert(not (catch setmetatable(a, {})))
    a.name = "gororoba"
    assert(tostring(a) == "gororoba")
end)

tests:it("__index and __newindex", function()
    local t = {}
    local mt = {
        __index = function(t,k) return "got " .. k end,
        __newindex = function(t,k,v) rawset(t, k, "set " .. v) end
    }
    setmetatable(t, mt)
    assert(t.foo == "got foo")
    t.bar = "value"
    assert(t.bar == "set value")
end)

tests:it("__index chain with parent", function()
    local t = {}
    t.__index = function (t, i, e)
      assert(not e)
      local p = rawget(t, "parent")
      return (p and p[i]+3), "dummy return"
    end

    local a = setmetatable({10,20,30; x="10", y="20"}, t)
    a.parent = {z=25, x=12, [4] = 24}
    assert(a[1] == 10 and a.z == 28 and a[4] == 27 and a.x == "10")
end)

tests:it("__newindex function", function()
    local t = {}
    local a = setmetatable({}, t)
    local function f(t, i, v) rawset(t, i, v-3) end
    setmetatable(t, t)   -- causes a bug in 5.1 !
    t.__newindex = f
    a[1] = 30; a.x = "101"; a[5] = 200
    assert(a[1] == 27 and a.x == 98 and a[5] == 197)
end)

tests:it("__newindex table", function()
    local t = {}
    local c = {}
    local a = setmetatable({}, t)
    t.__newindex = c
    t.__index = c
    a[1] = 10; a[2] = 20; a[3] = 90;
    for i = 4, 20 do a[i] = i * 10 end
    assert(a[1] == 10 and a[2] == 20 and a[3] == 90)
    for i = 4, 20 do assert(a[i] == i * 10) end
    assert(next(a) == nil)  -- all went to c
end)

tests:it("arithmetic metamethods", function()
    local t = {}
    local function Op(x) return setmetatable({x=x}, t) end
    
    t.__add = function(a,b) 
        local av = type(a)=='table' and a.x or a
        local bv = type(b)=='table' and b.x or b
        return av + bv 
    end
    t.__sub = function(a,b)
        local av = type(a)=='table' and a.x or a
        local bv = type(b)=='table' and b.x or b
        return av - bv
    end
    t.__mul = function(a,b)
        local av = type(a)=='table' and a.x or a
        local bv = type(b)=='table' and b.x or b
        return av * bv
    end
    t.__div = function(a,b)
        local av = type(a)=='table' and a.x or a
        local bv = type(b)=='table' and b.x or b
        return av / bv
    end
    t.__unm = function(a)
        return -a.x
    end
    t.__pow = function(a,b)
        local av = type(a)=='table' and a.x or a
        local bv = type(b)=='table' and b.x or b
        return av ^ bv
    end
    
    assert(Op(10) + Op(20) == 30)
    assert(Op(30) - 10 == 20)
    assert(Op(5) * Op(4) == 20)
    assert(Op(20) / 4 == 5)
    assert(-Op(10) == -10)
    assert(Op(2) ^ 3 == 8)
end)

tests:it("comparison metamethods", function()
    local t = {}
    local function Op(x) return setmetatable({x=x}, t) end

    t.__lt = function (a,b)
      collectgarbage()
      if type(a) == 'table' then a = a.x end
      if type(b) == 'table' then b = b.x end
      return a<b
    end

    t.__le = function (a,b)
      if type(a) == 'table' then a = a.x end
      if type(b) == 'table' then b = b.x end
      return a<=b
    end

    t.__eq = function (a,b)
      if type(a) == 'table' then a = a.x end
      if type(b) == 'table' then b = b.x end
      return a == b
    end
    
    assert(not(Op(1)<Op(1)) and (Op(1)<Op(2)) and not(Op(2)<Op(1)))
    assert((Op(1)<=Op(1)) and (Op(1)<=Op(2)) and not(Op(2)<=Op(1)))
    assert(not(Op(1)>Op(1)) and not(Op(1)>Op(2)) and (Op(2)>Op(1)))
    assert((Op(1)>=Op(1)) and not(Op(1)>=Op(2)) and (Op(2)>=Op(1)))
    assert(Op(1) == Op(1) and Op(1) ~= Op(2))
end)

tests:it("partial order sets", function()
    local t = {}
    local function rawSet(x)
      local y = {}
      for _,k in pairs(x) do y[k] = 1 end
      return y
    end

    local function Set(x)
      return setmetatable(rawSet(x), t)
    end

    t.__lt = function (a,b)
      for k in pairs(a) do
        if not b[k] then return false end
        b[k] = nil
      end
      return next(b) ~= nil
    end

    t.__le = function (a,b)
      for k in pairs(a) do
        if not b[k] then return false end
      end
      return true
    end

    assert(Set{1,2,3} < Set{1,2,3,4})
    assert(not(Set{1,2,3,4} < Set{1,2,3,4}))
    assert((Set{1,2,3,4} <= Set{1,2,3,4}))
    assert((Set{1,2,3,4} >= Set{1,2,3,4}))
end)

tests:it("rawlen", function()
    local t = setmetatable({1,2,3}, {__len = function () return 10 end})
    assert(#t == 10)
    assert(rawlen(t) == 3)
    assert(rawlen"abc" == 3)
    assert(rawlen(string.rep('a', 1000)) == 1000)
    assert(not (catch rawlen(io.stdin)))
    assert(not (catch rawlen(34)))
    assert(not (catch rawlen()))
end)

tests:it("__call metamethod", function()
    local t = {}
    local function f (t, ...) return t, {...} end
    t.__call = f
    
    local a = setmetatable({}, t)
    local x,y = a(table.unpack{'a', 1})
    assert(x==a and y[1]=='a' and y[2]==1 and y[3]==nil)
    x,y = a()
    assert(x==a and y[1]==nil)
end)

tests:it("chained __call", function()
    local tt = {
      __call = function (t, ...)
        if t.f then return t.f(...)
        else return {...}
        end
      end
    }
    
    local a = setmetatable({}, tt)
    local b = setmetatable({f=a}, tt)
    local c = setmetatable({f=b}, tt)
    
    local x = c(3,4,5)
    assert(x[1] == 3 and x[3] == 5)
end)

tests:it("__concat metamethod", function()
    local t = {}
    t.__concat = function (a,b,c)
      assert(c == nil)
      if type(a) == 'table' then a = a.val end
      if type(b) == 'table' then b = b.val end
      return a..b
    end
    
    local c = setmetatable({val="c"}, t)
    local d = setmetatable({val="d"}, t)
    
    assert(c..d == 'cd')
    assert(0 .."a".."b"..c..d.."e".."f"..(5+3).."g" == "0abcdef8g")
end)

tests:it("metatables for basic types", function()
    local mt = {__index = function (a,b) return a+b end,
          __len = function (x) return math.floor(x) end}
    debug.setmetatable(10, mt)
    assert(getmetatable(-2) == mt)
    assert((10)[3] == 13)
    assert((10)["3"] == 13)
    assert(#3.45 == 3)
    debug.setmetatable(23, nil)
    assert(getmetatable(-2) == nil)
end)

tests:it("loops in delegation", function()
    local a = {}; setmetatable(a, a); a.__index = a; a.__newindex = a
    assert(not (catch (function (a,b) return a[b] end)(a, 10)))
    assert(not (catch (function (a,b,c) a[b] = c end)(a, 10, true)))
end)

tests:finish()

